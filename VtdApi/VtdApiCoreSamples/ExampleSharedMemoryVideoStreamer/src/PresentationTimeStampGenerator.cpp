#include "PresentationTimeStampGenerator.h"

#include "RdbRawImage.h"

extern "C" {
#include <libavutil/mathematics.h>
}

using namespace SharedMemoryStreaming;

namespace {

///
/// \brief Generate a PTS assuming the real input framerate is equal
/// to the target input framerate.
/// \param frameId The id of the input RDB image
/// \param inputFrameRate The target framerate of the input stream.
/// \param outputFrameRate The target framerate of the output stream.
/// \return The idealized PTS
///
int64_t generateIdealizedPts(
    const int64_t frameId
    , const AVRational inputFrameRate
    , const AVRational outputFrameRate)
{
    // Map the VIG frame ID (input ID) to the ID it should have if it is writen
    // (output ID)

    // Example: IG renders at 60 Hz, output video displays at 30 Hz
    // IG renders twice as many frames as the output stream requires.
    // Pairs of input ID's are mapped to the same output ID
    // ID's [0,1] are mapped to 0 / [2,3] -> 1 / [4,5] -> 2 ...

    // Example: IG renders at 30 Hz, output video displays at 60 Hz
    // IG renders only half as many frames as the output stream requires.
    // Every second output ID is skipped
    // ID's [0] is mapped to 0 / [1] -> 2 / [2] -> 4 ...
    return av_rescale_q(
        frameId, outputFrameRate, inputFrameRate);
}

} // namespace {

PresentationTimeStampGenerator::PresentationTimeStampGenerator(
    const AVRational& inputFrameRate
    , const AVRational& outputFrameRate)
    : inputFrameRate_(inputFrameRate)
    , outputFrameRate_(outputFrameRate)
    , isFirstFrame_(true)
    , numberOfSkippedFrames_(0)
{
}

int64_t PresentationTimeStampGenerator::generate(
    const RdbRawImage& rdbImage)
{
    // The generated presentation time stamp.
    int64_t pts;

    if (isFirstFrame_)
    {
        // This is the first time an timestamp is generated
        isFirstFrame_ = false;
        // The first pts shall be zero.
        // Future pts must not be smaller than the last generated one.
        pts = 0;
        // Remember the ID of the first frame.
        firstSeenFrameId_ = rdbImage.imageHeader.id;
    }
    else
    {
        if (rdbImage.imageHeader.id < lastSeenFrameId_)
        {
            // Frame Id got smaller, image generator was propably restarted.
            numberOfSkippedFrames_ -=
                (lastSeenFrameId_ - rdbImage.imageHeader.id) + 1;
        }
        else if (rdbImage.imageHeader.id > lastSeenFrameId_ + 1)
        {
            // In order to avoid generating a PTS that has a large gap to the
            // predecessor, due to missed frames, skip the gap.
            numberOfSkippedFrames_ +=
                (rdbImage.imageHeader.id - lastSeenFrameId_) - 1;
        }

        // Generate a frameid PTS that is bassed on the assumption that
        // the real framerate of the input video source (the IG) is exactly
        // equal to the target framerate.

        // Start with the original frameid generated by the IG
        int64_t adjustedFrameId = int64_t(rdbImage.imageHeader.id);
        // Adjust frame id for very large gaps so that the resulting video stream
        // does not contain large pauses.
        adjustedFrameId -= numberOfSkippedFrames_;
        // Adjust id for the first frame id that has ever been seen.
        // One should not assume that the first frame received, has the ID zero
        // or is at least one of the first frames ever being generated.
        // Allows the generated PTS to begin at zero.
        adjustedFrameId -= firstSeenFrameId_;

        // Generate the output ID while considering possible sources
        const int64_t idealPts = generateIdealizedPts(
            adjustedFrameId
            , inputFrameRate_
            , outputFrameRate_);

        pts = idealPts;
    }

    // Save the frame id to detect large differences.
    lastSeenFrameId_ = rdbImage.imageHeader.id;

    return pts;
}
